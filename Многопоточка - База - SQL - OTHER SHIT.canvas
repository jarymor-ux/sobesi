{
  "edges": [
  ],
  "nodes": [
    {
      "height": 1300,
      "id": "f58c9fe49f84ae20",
      "styleAttributes": {
      },
      "text": "Ниже приведён краткий конспект по заданным темам:\n\n---\n\n### 1. Оптимизация SQL-запроса с тремя фильтрами в WHERE\n\n**Описание:**  \nИндексация используется для ускорения поиска строк по заданным критериям. При наличии нескольких фильтров важно учитывать селективность – чем выше селективность (то есть, чем меньше строк удовлетворяют условию) – тем эффективнее индекс.  \n**Подходы и методы:**\n\n- **Составной (композитный) индекс:**  \n    Создается по нескольким полям. Важно правильно выбрать порядок полей – сначала включают поле с наивысшей селективностью, затем менее селективные.  \n    _Пример:_\n    \n    ```sql\n    CREATE INDEX idx_table_fields ON table(field_high_selectivity, field_medium, field_low);\n    ```\n    \n- **Отдельные индексы:**  \n    Если селективность сильно различается, может быть полезно создать отдельные индексы для наиболее селективных полей, позволяющие оптимизатору выбирать лучший план.\n\n---\n\n### 2. SQL и NoSQL базы данных\n\n**Описание:**\n\n- **SQL (реляционные) базы данных:**  \n    Используют строгую схему, поддерживают SQL как язык запросов, обеспечивают целостность данных и транзакционность. Применяются для структурированных данных и сложных запросов с объединениями (JOIN).\n- **NoSQL базы данных:**  \n    Предназначены для гибкого хранения неструктурированных или полуструктурированных данных, легко масштабируются горизонтально. Часто используются для работы с большими объёмами данных и высокой нагрузкой.  \n    **Основные моменты:**\n- **SQL:** транзакции, нормализация, сложные связи между таблицами.\n- **NoSQL:** масштабирование, денормализация, гибкая схема.\n\n---\n\n### 3. Индексы в базах данных\n\n**Описание:**  \nИндексы – это специальные структуры данных (чаще всего B-деревья, хеш-таблицы или их вариации), позволяющие ускорить поиск строк в таблице за счёт быстрого доступа к нужным записям.  \n**Плюсы:**\n\n- Значительное ускорение выборок по индексированным колонкам.  \n    **Ограничения:**\n- **Замедление операций вставки, обновления и удаления:** Каждый раз требуется обновлять индекс.\n- **Использование дополнительного дискового пространства:** Индексы занимают место на диске.\n- **Сложности с выбором оптимального индекса:** Неправильно составленный индекс может даже ухудшить производительность.  \n    **Методы доступа:**\n- **B-tree индекс:** стандарт для большинства СУБД.\n- **Hash индекс:** используется для точного поиска (но не для диапазонных запросов).\n\n---\n\n### 4. Уровни изоляции транзакций\n\n**Описание:**  \nИзоляция транзакций определяет, как изменения, сделанные одной транзакцией, видны другим, тем самым контролируя такие явления, как \"грязное чтение\", \"неповторяемое чтение\" и фантомы.  \n**Основные уровни:**\n\n- **Read Uncommitted:**  \n    Позволяет видеть незавершенные изменения других транзакций (грязное чтение).\n- **Read Committed:**  \n    Запрещает грязное чтение; каждая выборка видит только зафиксированные изменения, но возможны неповторяемые чтения.\n- **Repeatable Read:**  \n    Гарантирует, что повторные выборки в рамках транзакции вернут одинаковые результаты, предотвращая неповторяемое чтение, но допускает фантомное чтение.\n- **Serializable:**  \n    Самый высокий уровень изоляции, имитирующий последовательное выполнение транзакций; предотвращает все виды аномалий, но снижает производительность.  \n    **Дополнительно:**  \n    Некоторые СУБД поддерживают **Snapshot Isolation**, позволяющую работать с копией данных на момент начала транзакции.\n\n---\n\n### 5. Шардинг, репликация и партиционирование\n\n**Описание:**  \nВсе эти техники применяются для повышения производительности, масштабируемости и отказоустойчивости систем хранения данных.\n\n- **Шардинг:**  \n    Разделение данных на несколько серверов (узлов) по определенному ключу.  \n    **Использование:**\n    \n    - Горизонтальное масштабирование больших объёмов данных.\n    - Методы: шардинг по диапазону (range-based) или по хешированию ключа.\n- **Репликация:**  \n    Создание копий данных на разных серверах для повышения доступности и обеспечения отказоустойчивости.  \n    **Использование:**\n    \n    - Балансировка нагрузки при чтении.\n    - Методы: синхронная репликация (данные записываются одновременно на несколько узлов) и асинхронная репликация (запись происходит с задержкой).\n- **Партиционирование:**  \n    Логическое разделение одной таблицы на несколько частей (партиций) в пределах одного сервера, что позволяет ускорить выполнение запросов за счет работы с меньшими объемами данных.  \n    **Использование:**\n    \n    - Улучшение управляемости больших таблиц.\n    - Методы: партиционирование по диапазону, списку или хешу.\n\n---\n\n### 6. Пример оптимизации запроса в базе данных\n\n**Описание:**  \nОптимизация запроса обычно направлена на снижение времени выполнения и нагрузки на сервер.  \n**Пример ситуации:**\n\n- Имелся сложный запрос с множественными JOIN и фильтрами по нескольким полям, который выполнялся слишком медленно.\n- **Действия:**\n    - Проведен анализ плана выполнения (EXPLAIN), выявлены узкие места – отсутствовали необходимые индексы, а структура запроса была не оптимальной.\n    - Создан составной индекс на наиболее селективных полях, изменен порядок соединения таблиц, переписаны части запроса для сокращения количества сканируемых строк.\n- **Результат:**  \n    Время выполнения запроса снизилось с нескольких секунд до долей секунды.\n\n---\n\n### 7. Анализ выполнения запроса\n\n**Описание:**  \nАнализ запроса помогает понять, как СУБД выполняет запрос, какие индексы используются, и где возникают узкие места.  \n**Методы анализа:**\n\n- **EXPLAIN/EXPLAIN ANALYZE:**  \n    Выводит план выполнения запроса, показывая, какие операции выполняются и с какой стоимостью.\n- **Профилирование запросов:**  \n    Использование специальных инструментов для мониторинга выполнения запросов (например, slow query log).\n- **Мониторинг ресурсов:**  \n    Отслеживание использования CPU, памяти и дисковых операций для выявления нагрузок на сервер.\n\n---\n\n",
      "type": "text",
      "width": 940,
      "x": 2380,
      "y": -460
    },
    {
      "height": 1300,
      "id": "36a4b33fc1991061",
      "styleAttributes": {
      },
      "text": "### 2. Что такое горутины? В чём их преимущества над потоками?\n\n- **Описание**: Горутины (goroutines) — это лёгкие потоки выполнения в Go.\n- **Зачем нужны**: Позволяют писать конкурентный код проще и эффективнее, чем при работе с “тяжёлыми” потоками ОС. Они имеют меньший overhead и создаются гораздо быстрее.\n- **Пример функций/методов**:\n    - **`go someFunction()`** – запуск функции в отдельной горутине.\n    - **`runtime.NumGoroutine()`** – возвращает текущее количество горутин.\n\n---\n\n### 3. Расскажи про модель MGP\n\n- **Описание**: Модель MGP (Machine, Goroutine, Processor) — это внутренний механизм планировщика Go.\n    - **M (Machine)** – нить (thread) ОС.\n    - **P (Processor)** – логический “процессор” или планировщик, отвечающий за исполнение горутин на одном M.\n    - **G (Goroutine)** – сама горутина, очередь выполняемых функций.\n- **Зачем нужно**: Позволяет Go эффективно распределять множество горутин по ограниченному количеству системных потоков.\n- **Пример функций/методов** (из пакета `runtime`):\n    - **`runtime.GOMAXPROCS(n int)`** – задаёт максимальное число P (логических процессоров), которые могут одновременно выполнять горутины.\n    - **`runtime.GC()`** – хотя напрямую не относится к MGP, часто упоминается при разговоре о механизмах рантайма Go.\n### 5. Конструкция `select case` гарантирует порядок?\n\n- **Описание**: `select` позволяет ждать операций над несколькими каналами одновременно.\n- **Зачем нужно**: Упрощает конкурентную логику: мы выбираем, из какого канала первым поступят данные или какая операция пройдёт первой.\n- **Порядок**:\n    - Go **не гарантирует** приоритет одного `case` над другим, если они оба готовы одновременно. Выбор происходит псевдослучайным образом.\n    - Однако если какой-то `case` готов раньше других, он будет выбран сразу.\n- **Методы/функции**: `select` – это не функция, а конструкция языка. Специальных методов у неё нет, но используется совместно с операциями отправки/чтения из каналов.\n\n---\n\n### 6. Писать/читать в закрытый канал можно? Что произойдёт при чтении?\n\n- **Описание**: Когда канал закрыт с помощью `close(ch)`, это означает, что в канал больше нельзя ничего отправлять.\n- **Зачем нужно**: Явное закрытие канала сообщает горутинам-получателям, что больше не будет никаких значений.\n- **Поведение**:\n    - **Запись (send) в закрытый канал** приводит к панике (`panic`).\n    - **Чтение (receive) из закрытого канала**:\n        - Если канал ещё содержит буферизированные значения, то можно прочитать их до тех пор, пока они не закончатся.\n        - Как только значения заканчиваются, дальнейшие чтения вернут «нулевое» значение типа и признак, что канал закрыт (`ok == false` в конструкции `v, ok := <-ch`).\n- **Методы/функции**:\n    - **`close(ch)`** – закрывает канал (выполняется только отправляющей стороной).\n    - **Операция чтения** – `v, ok := <-ch`.\n\n---\n\n### 7. Как канал устроен под капотом?\n\n- **Описание (в упрощённом виде)**:\n    - Канал — это структура в рантайме Go, содержащая кольцевой буфер (для буферизированных каналов), а также очереди отправителей и получателей (для синхронных операций).\n    - При записи в полный буфер или чтении из пустого канала горутина блокируется, пока операция не сможет быть выполнена.\n- **Зачем нужно**: Каналы — основной механизм коммуникации и синхронизации горутин.\n- **Пример функций/методов**:\n    - У самого типа `chan` в Go “явных” методов нет, взаимодействие идёт через синтаксис `<-` и `close(ch)`.\n    - **`len(ch)`** и **`cap(ch)`** (встроенные функции) позволяют узнать текущую длину и ёмкость буфера канала.\n### 9. Про GC. Как он работает, алгоритм, когда запускается? Можно ли как-то отключить его или ограничить?\n\n- **Описание**: В Go используется **маркировка и сбор** (Mark-and-Sweep) с элементами **Concurrent GC**: сборка мусора идёт параллельно с работой программы, минимизируя паузы.\n- **Зачем нужно**: Избавляет разработчика от ручного управления памятью.\n- **Когда запускается**:\n    - Автоматически по эвристикам Go (учитывая распределённую память, число живых объектов, т.д.).\n    - Можно вызвать вручную через `runtime.GC()`, но в продакшене это обычно не рекомендуется.\n- **Можно ли отключить или ограничить**:\n    - Полностью отключить сборщик мусора нельзя (это фундамент Go).\n    - **`debug.SetGCPercent(x)`** — позволяет регулировать “триггер” запуска GC. Если установить в отрицательное значение, сборка будет происходить только при явном `runtime.GC()`.\n- **Пример функций/методов**:\n    - **`runtime.GC()`** – запускает сборщик мусора вручную.\n    - **`debug.SetGCPercent()`** – регулирует процент от прироста кучи, при котором стартует GC.\n\n---\n\n### 10. Приходилось сталкиваться с профилированием?\n\n- **Описание**: Профилирование (profiling) в Go позволяет измерять производительность кода (CPU, память, блокировки и др.).\n- **Зачем нужно**: Чтобы понимать, где в программе узкие места, и оптимизировать потребление ресурсов.\n- **Основные инструменты**:\n    - **`pprof`** (пакет `runtime/pprof` и `net/http/pprof`) – стандартный инструмент для сбора профилей CPU, памяти, горутин.\n    - **`go tool pprof`** – для анализа собранных профилей.\n- **Пример работы**:\n    - Вставка кода профилирования:",
      "type": "text",
      "width": 940,
      "x": 3320,
      "y": -460
    },
    {
      "height": 1300,
      "id": "b7c5ec10bd0315dc",
      "styleAttributes": {
      },
      "text": "### 1. Слайс\n\n**Описание:**  \nСлайс – это динамическая структура, представляющая собой окно (подмножество) на базовый массив. Он хранит указатель на массив, его длину и вместимость. Используется для работы с коллекциями, когда размер может меняться в процессе выполнения программы.  \n**Назначение:**  \nУдобное и гибкое хранение последовательностей данных с возможностью динамического изменения размера.  \n**Ключевые операции (функции):**\n\n- `append(slice, elems…)` – добавление элементов;\n- `copy(dst, src)` – копирование данных из одного слайса в другой.\n\n---\n\n### 2. Канал\n\n**Описание:**  \nКанал – это средство синхронизации и обмена данными между горутинами. Он обеспечивает безопасную передачу значений и помогает организовывать взаимодействие между параллельно выполняющимися частями программы.  \n**Назначение:**  \nОбеспечение коммуникации между горутинами, синхронизация их работы и предотвращение гонок при доступе к общим данным.  \n**Ключевые операции:**\n\n- Отправка: `ch <- value`;\n- Получение: `value := <- ch`;\n- Закрытие канала: `close(ch)`.\n\n---\n\n### 3. Контекст\n\n**Описание:**  \nКонтекст (тип `context.Context`) – это инструмент для передачи сигналов отмены, дедлайнов и метаданных между горутинами.  \n**Назначение:**  \nОрганизация контроля за временем выполнения, отменой операций (например, HTTP-запросов) и передачи служебной информации в рамках запроса.  \n**Особенности передачи данных:**  \nПередавать через контекст большие объёмы данных не рекомендуется, поскольку контекст предназначен только для сигналов и метаданных. Использование его для хранения большого количества данных может привести к ухудшению читаемости кода, ошибкам и потенциальным утечкам памяти.\n\n---\n\n### 4. Примеры race condition\n\n**Описание:**  \nRace condition (состояние гонки) возникает, когда несколько горутин одновременно обращаются к общему ресурсу без должной синхронизации, что приводит к некорректному поведению программы.  \n**Примеры:**\n\n- Параллельное инкрементирование счётчика без использования мьютекса;\n- Одновременное чтение и запись в мапу или слайс без защиты;\n- Несинхронизированное обновление состояния объекта.\n\n---\n\n### 5. Случаи, когда не выполняется `defer`\n\n**Описание:**  \n`defer` – это механизм отложенного вызова функции, который выполняется при выходе из функции.  \n**Когда не срабатывает:**\n\n- **При вызове `os.Exit`:** Функция `os.Exit` завершает программу немедленно, без выполнения отложенных вызовов.\n- **При аварийном завершении процесса:** Например, при получении сигнала, приводящего к немедленному завершению (как SIGKILL), или при фатальной ошибке, которая приводит к аварийному завершению.\n\n---\n\n### 6. Арена памяти\n\n**Описание:**  \nАрена памяти – это область, выделенная системой управления памятью (runtime) для эффективного распределения и освобождения памяти.  \n**Назначение:**  \nСлужит для оптимизации аллокации небольших объектов, сокращения фрагментации и повышения производительности сборщика мусора.  \n**Особенности:**  \nАрена используется под капотом и не предназначена для прямого управления программистом.\n\n---\n\n### 7. Fatal Error: deadlock\n\n**Описание:**  \nОшибка `fatal error: all goroutines are asleep - deadlock!` возникает, когда все активные горутины находятся в состоянии ожидания, и ни одна из них не может продолжить выполнение, что приводит к полной блокировке программы.  \n**Причины:**\n\n- Все горутины заблокированы на операциях каналов (отправка/прием) без возможности продолжения работы;\n- Отсутствует горутина, которая могла бы разблокировать ситуацию (например, не производится отправка в канал, из которого кто-то ожидает получение).  \n    **Замечание:**  \n    Это сообщение говорит о том, что состояние программы оказалось безвыходным с точки зрения планировщика.\n\n---\n\n### 8. Работа функции `append` для слайсов\n\n**Описание:**  \nФункция `append` используется для добавления одного или нескольких элементов к слайсу.  \n**Механизм работы:**\n\n- **Если вместимость позволяет:** Слайс расширяется, изменяется только его длина, а базовый массив остаётся прежним;\n- **Если вместимость недостаточна:** Выделяется новый массив с увеличенной вместимостью (обычно в 2 раза больше), копируются старые элементы, добавляется новый элемент, и возвращается новый слайс.  \n    **Замечание:**  \n    Этот механизм позволяет избежать постоянного копирования при небольшом увеличении размера, но в некоторых случаях приводит к дополнительным аллокациям.\n\n---\n\n### 9. Мапы в Go и их устройство\n\n**Описание:**  \nМапа – это встроенная структура данных, реализующая ассоциативный массив (хэш-таблицу) для хранения пар «ключ-значение».  \n**Назначение:**  \nОбеспечивает быстрый доступ (среднее время O(1)) к данным по ключу.  \n**Устройство под капотом:**\n\n- Использует хэш-функцию для вычисления позиции ключа;\n- Хранит данные в «бакетах» (корзинах), где могут находиться несколько пар;\n- Имеется механизм расширения (rehash) при превышении определённого порога заполнения.  \n    **Основные операции:**\n- Чтение: `value := myMap[key]`;\n- Запись: `myMap[key] = value`;\n- Удаление: `delete(myMap, key)`;\n- Итерация: с помощью цикла `for k, v := range myMap`.\n\n---\n\n### 10. GoMaxProcs\n\n**Описание:**  \n`GOMAXPROCS` – это параметр, задающий максимальное число ОС-потоков, одновременно исполняющих Go-код.  \n**Назначение:**  \nКонтролирует уровень параллелизма в программе, влияя на производительность при использовании многопоточности.  \n**Настройка:**\n\n- Программно: через функцию `runtime.GOMAXPROCS(n)`, где `n` – нужное количество потоков;\n- Через переменную окружения `GOMAXPROCS`;\n- По умолчанию равен количеству ядер процессора.\n\n---\n\n### 11. Планировщик (шедулер) в Go\n\n**Описание:**  \nПланировщик горутин в Go реализует модель M:N – множество горутин распределяются по меньшему числу ОС-потоков.  \n**Назначение:**  \nОбеспечивает эффективное распределение вычислительных ресурсов между горутинами, минимизируя накладные расходы и повышая производительность параллельного выполнения.  \n**Механизм работы:**\n\n- Использует алгоритм work-stealing для балансировки нагрузки между потоками;\n- Переключает горутины, которые ожидают (например, на каналах или во время сна), на выполнение других;\n- Оптимизирует использование процессорного времени, позволяя динамически изменять план выполнения.\n\n---\n\n### 12. Контекст в Go (повтор темы)\n\n**Описание:**  \n(Как и в пункте 3) Контекст (`context.Context`) предназначен для передачи сигналов отмены, дедлайнов и дополнительных метаданных между горутинами.  \n**Назначение:**  \nИспользуется для управления временем выполнения операций (например, HTTP-запросов) и для координации отмены нескольких взаимосвязанных задач.  \n**Рекомендация по использованию:**  \nНельзя использовать для передачи больших объёмов данных – контекст создан для служебной информации, а не для хранения данных, поскольку это может привести к усложнению логики и утечкам памяти.\n\n---\n\n### 13. Отличия слайса от массива; параметры слайса\n\n**Отличия:**\n\n- **Массив:** имеет фиксированную длину, часть его типа (например, `[5]int`); при передаче в функцию массив копируется целиком.\n- **Слайс:** динамический, его длина может меняться, содержит указатель на базовый массив, длину и вместимость; передаётся как структура с указателем, поэтому копирование не дублирует данные.  \n    **Параметры слайса:**\n- **Указатель:** на первый элемент базового массива;\n- **Длина (`len`):** количество элементов в слайсе;\n- **Вместимость (`cap`):** максимальное число элементов, которые можно разместить без выделения нового массива.\n\n---\n\n### 14. Исключения в Go и их обработка\n\n**Описание:**  \nВ Go нет традиционных исключений, как в Java или Python.  \n**Способы обработки ошибок:**\n\n- **Ошибки (error):** Функции возвращают значение типа `error`, которое нужно проверять. Это основной механизм для обработки предсказуемых ошибок.\n- **panic и recover:**\n    - `panic` используется для аварийного завершения выполнения в критических ситуациях;\n    - `recover` позволяет перехватить панику и восстановить управление (обычно применяется в отложенных функциях).  \n        **Назначение:**  \n        Такой подход способствует явному управлению ошибками и предотвращению неожиданного завершения программы без возможности корректного завершения работы.",
      "type": "text",
      "width": 940,
      "x": 1440,
      "y": -460
    },
    {
      "height": 1300,
      "id": "dbf7d19032671a6c",
      "styleAttributes": {
        "border": "dotted",
        "textAlign": "center"
      },
      "text": "### 1. Примитивы синхронизации в Go\n\n**Назначение:** Обеспечивают корректное и безопасное взаимодействие между горутинами, предотвращая гонки данных и другие проблемы конкурентного доступа.\n\n- **Mutex**\n    \n    - **Зачем нужен:** Для обеспечения взаимного исключения при доступе к разделяемым ресурсам.\n    - **Методы:** `Lock()`, `Unlock()`.\n- **RWMutex**\n    \n    - **Зачем нужен:** Для разделения доступа: множество горутин могут читать одновременно, а запись осуществляется эксклюзивно.\n    - **Методы:** `RLock()`, `RUnlock()`, `Lock()`, `Unlock()`.\n- **WaitGroup**\n    \n    - **Зачем нужен:** Для ожидания завершения группы горутин.\n    - **Методы:** `Add(delta int)`, `Done()`, `Wait()`.\n- **Cond**\n    \n    - **Зачем нужен:** Для организации сложной синхронизации, где горутины ждут наступления определённого условия.\n    - **Методы:** `Wait()`, `Signal()`, `Broadcast()`.\n- **Once**\n    \n    - **Зачем нужен:** Для гарантии однократного выполнения определённой инициализации или функции.\n    - **Метод:** `Do(func())`.\n- **Пакет atomic**\n    \n    - **Зачем нужен:** Для выполнения атомарных операций над переменными (без использования блокировок).\n    - **Примеры методов:** `atomic.AddInt32()`, `atomic.LoadInt32()`, `atomic.StoreInt32()` и т.д.\n- **Каналы (channels)**\n    \n    - **Зачем нужны:** Для передачи данных между горутинами и организации синхронизации по принципу «не делись памятью – передавай сообщение».\n\n---\n\n### 2. Работа с nil-каналами\n\n- **Чтение из nil-канала:** Операция блокируется навсегда, так как nil-канал никогда не становится готовым.\n- **Запись в nil-канал:** Также блокируется навсегда.\n- **Закрытие nil-канала:** Вызывает **panic** с сообщением «close of nil channel», так как закрывать нечего.\n\n---\n\n### 3. Select\n\n**Назначение:** Позволяет ожидать нескольких операций над каналами одновременно и выполнять ту, которая станет доступной первой.\n\n- **Запись и чтение:** В `select` можно указывать **case** как для чтения (например, `case x := <-ch:`), так и для записи (например, `case ch <- y:`).\n- **Особенности:**\n    - Если несколько операций готовы – выбор происходит случайным образом.\n    - Наличие `default` позволяет выполнить действие, если ни один из каналов не готов к операции.\n\n---\n\n### 4. Передача данных между горутинами по каналу\n\n**Назначение:** Обеспечивает безопасное взаимодействие между горутинами через передачу данных без использования разделяемой памяти.\n\n- **Как происходит передача:**\n    - Данные, отправленные в канал, копируются. Это означает, что значение, помещённое в канал, копируется из контекста (например, стека) горутины-отправителя в контекст горутины-получателя.\n    - Такая передача исключает проблемы гонок, так как получатель работает с копией данных.\n\n---\n\n### 5. Мапы и многопоточность\n\n**Проблема:** Стандартные (обычные) мапы в Go **не являются потокобезопасными**. Конкурентные операции (запись и чтение) без защиты приводят к гонкам данных и могут вызвать **panic**.\n\n- **Использование Mutex с мапой:**\n    \n    - **Зачем нужно:** Обеспечить синхронизированный доступ к мапе, вручную блокируя операции.\n    - **Подход:** Оборачивать каждую операцию с мапой в `Lock()`/`Unlock()`.\n- **sync.Map:**\n    \n    - **Зачем нужен:** Потокобезопасная альтернатива обычной мапе, оптимизированная для сценариев с высоким уровнем конкурентного доступа.\n    - **Методы:**\n        - `Load(key interface{}) (value interface{}, ok bool)`\n        - `Store(key, value interface{})`\n        - `Delete(key interface{})`\n        - `LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)`\n        - `Range(func(key, value interface{}) bool)`\n\n---\n\n### 6. Конкурентность vs Параллелизм\n\n- **Конкурентность:**\n    \n    - **Определение:** Возможность управлять несколькими задачами, переключаясь между ними (интерливинг), даже если они не выполняются одновременно.\n    - **Реализация в Go:** Через горутины и каналы, где планировщик (scheduler) Go runtime управляет переключением между горутинами.\n- **Параллелизм:**\n    \n    - **Определение:** Одновременное выполнение нескольких задач на разных процессорных ядрах или потоках.\n    - **Реализация в Go:**\n        - При наличии нескольких ядер и настроенном `GOMAXPROCS` (значение больше 1) планировщик может запускать горутины параллельно на разных ОС-потоках.",
      "type": "text",
      "width": 940,
      "x": 500,
      "y": -460
    }
  ]
}