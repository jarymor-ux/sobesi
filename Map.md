В [коде sync.RWMutex](https://dzen.ru/away?to=https%3A%2F%2Fgolang.org%2Fsrc%2Fsync%2Frwmutex.go%23L90) можно увидеть, что при блокировке на чтение, каждая горутина атомарно обновляет счетчик **readerCount**. Когда ядро процессора обновляет счётчик, оно сбрасывает кеш для этого адреса в памяти для всех остальных ядер и объявляет, что владеет актуальным значением для адреса. Следующее ядро, прежде чем обновить счётчик, сначала вычитывает это значение из кеша другого ядра.

Передача между L2 кешем занимает ~ 40 нс. Когда много ядер одновременно пытаются обновить счётчик, то каждое становится в очередь и ждёт инвалидацию и вычитывание из кеша. Операция, которая должна укладываться в константное время внезапно становится O(N) по количеству ядер. Это и есть **cache contention**.

Для этой конкретной проблемы, когда у нас много ядер и система высоконагружена, можно использовать **sync.Map** вместо стандартной **map** с **RWMutex**. В остальных случаях **sync.Map** не нужен.